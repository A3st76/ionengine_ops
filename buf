/*std::unique_ptr<gfx::Resource> resources[10];

        for(uint32 i = 0; i < 1; ++i)
        {
            gfx::ResourceDesc res_desc{};
            res_desc.dimension = gfx::ViewDimension::Buffer;
            res_desc.width = 64_kb;
            res_desc.height = 1;
            res_desc.mip_levels = 1;
            res_desc.array_size = 1;
            res_desc.flags = gfx::ResourceFlags::ConstantBuffer;
            resources[i] = m_device->create_resource(gfx::ResourceType::Buffer, gfx::MemoryType::Default, res_desc);
        }

        gfx::ViewDesc view_desc{};
        view_desc.buffer_size = resources[0]->get_desc().width;
        auto view = m_device->create_view(gfx::ViewType::ConstantBuffer, resources[0].get(), view_desc);

        std::vector<gfx::BindingSetBinding> bindings = {
            { gfx::ShaderType::Vertex, gfx::ViewType::ConstantBuffer, 0, 0, 1 }
        };

        auto binding_set_layout = m_device->create_binding_set_layout(bindings);
        auto binding_set = m_device->create_binding_set(binding_set_layout.get());

        gfx::WriteBindingSet write = {
            0,
            1,
            gfx::ViewType::ConstantBuffer,
            { { view.get() } }
        };

        binding_set->write(write);

        gfx::RenderPassDesc render_pass_desc{};
        auto render_pass = m_device->create_render_pass(render_pass_desc);

        gfx::GraphicsPipelineDesc pipeline_desc{};
        pipeline_desc.vertex_inputs = {
            { "POSITION", 0, gfx::Format::RGB32float, 0, 0 }
        };
        pipeline_desc.render_pass = render_pass.get();
        pipeline_desc.layout = binding_set_layout.get();
        pipeline_desc.shaders = { 
            { gfx::ShaderType::Vertex, "shaders/pc/basic_vert.bin" },
            { gfx::ShaderType::Pixel, "shaders/pc/basic_frag.bin" },
        };
        auto pipeline = m_device->create_pipeline(pipeline_desc);*/